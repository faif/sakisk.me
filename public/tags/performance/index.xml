<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Sakis Kasampalis - Personal homepage</title>
    <link>http://localhost:1313/tags/performance/</link>
    <description>Recent content in Performance on Sakis Kasampalis - Personal homepage</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Jan 2015 21:30:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Course review: SQL Performance</title>
      <link>http://localhost:1313/blog/2015-01-14-course-review-sql-performance/</link>
      <pubDate>Wed, 14 Jan 2015 21:30:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2015-01-14-course-review-sql-performance/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;b&gt;Update:&lt;/b&gt; Markus was kind enough to comment on my review. Regarding the &#34;minimise the number of tables to limit joins&#34; he said:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;it is often the best approach to store some attribute redundant (e.g.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica;&#34;&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;normalised&amp;nbsp;as before plus wherever needed). Maintenance of this&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;redundancy should be delegated to the database whenever possible (e.g.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica;&#34;&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;using triggers or&amp;nbsp;materialised&amp;nbsp;view). You should not do that before&amp;nbsp;having those performance problems (avoid &#34;premature&amp;nbsp;optimisation&#34;).&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;Reducing the number of joins is a good way to get performance. But only once you are in that situation. And of course, there are other, simpler ways to improve performance that should be leveraged first (e.g, good-old indexing).&lt;/span&gt;&lt;/blockquote&gt;So I&#39;m glad that we agree that normalisation is a good thing and that we should only try to find alternative solutions if nothing else (e.g. proper indexing) works.&lt;br /&gt;&lt;br /&gt;Markus also made an important comment about the column order in the WHERE clause that is not clarified in my original post:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;The column order in indexes matters a lot&lt;/span&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;The column order in the WHERE clause doesn&#39;t matter (rare exceptions exist, but generally, it doesn&#39;t!).&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;br /&gt;&lt;br /&gt;The original post starts here...&lt;br /&gt;&lt;br /&gt;Last &lt;strike&gt;October&lt;/strike&gt;&amp;nbsp;November I followed a course related to the performance of SQL. The course was given by &lt;a href=&#34;http://use-the-index-luke.com/&#34;&gt;Markus Winand&lt;/a&gt;. Although we don&#39;t agree on everything (for example I don&#39;t like the &#34;create as few tables as possible to minimise joins and achieve better performance&#34; principle because it is against normalisation) Markus has a great knowledge of general and RDBMS-specific performance related issues.&lt;br /&gt;&lt;br /&gt;I&#39;m glad that I followed this course. Markus gave us a copy of &lt;a href=&#34;http://sql-performance-explained.com/?utm_source=UTIL&amp;amp;utm_medium=main&amp;amp;utm_campaign=second&#34;&gt;his book&lt;/a&gt; which is very compact and to the point. This is an example of a book that I would never consider reading but it turns out to be a hidden gem. I recommend it to everyone working with relational databases.&lt;br /&gt;&lt;br /&gt;It took me some time to write this post because I wanted to read the book first. In this book you will find things that you don&#39;t know for sure. For example, did you know that:&lt;br /&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;When building indexes on more than one columns (concatenated indexes), the order of the columns matters a lot?&lt;/li&gt;&lt;li&gt;The order of the statements in the &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;WHERE&lt;/span&gt; part of a query affects whether a concatenated index is used or not?&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;LIKE&lt;/span&gt; expressions with leading wildcards (eg. &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;&#39;%SQL&#39;&lt;/span&gt;) cannot make use of an index?&lt;/li&gt;&lt;li&gt;ORMs can cause big performance problems because of the bad queries that they generate?&lt;/li&gt;&lt;li&gt;Selecting only the necessary columns (avoid &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;SELECT *&lt;/span&gt;) can improve the performance of joins?&lt;/li&gt;&lt;li&gt;An index that covers all the columns of an SQL query (including the columns of the &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;SELECT&lt;/span&gt; part) does not need to access any other data structures except the index and improves the performance of a query enormously?&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;ORDER BY&lt;/span&gt; and &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;GROUP BY&lt;/span&gt; can also be indexed?&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The main message of the book is that indexes should be built by us, the developers, not by DBAs or anyone else. That&#39;s because only we know how the data are queried, and therefore only we can build the proper indexes.&lt;br /&gt;&lt;br /&gt;Personally, I&#39;m very sad to see how many features that are supported by other RDBMS are not supported by MySQL. To mention a few: indexing functions and expressions, partial indexes, indexing using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;ASC&lt;/span&gt; and &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;DESC&lt;/span&gt;, window functions. Fortunately, MariaDB is getting there and I hope that we&#39;ll switch to it (at work) at some point.&lt;/div&gt;</description>
    </item>
    <item>
      <title>Two less common tricks for improving unexplained slow MySQL queries</title>
      <link>http://localhost:1313/blog/2014-11-08-two-less-common-tricks-for-improving/</link>
      <pubDate>Sat, 08 Nov 2014 22:26:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2014-11-08-two-less-common-tricks-for-improving/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;Recently I faced an SQL performance issue. What I wanted to do was rather common: Apply the (set) difference operation on two tables.&lt;br /&gt;&lt;br /&gt;In relational algebra, the difference operation applied on two tables &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;A&lt;/span&gt; and &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;B&lt;/span&gt; gives as a result a new table &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;C&lt;/span&gt; that contains all the elements that are in table &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;A&lt;/span&gt; but &lt;b&gt;aren&#39;t&lt;/b&gt; in table &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;B&lt;/span&gt;.&lt;br /&gt;&lt;br /&gt;That&#39;s a very common operation. A common example is having the table &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;Students&lt;/span&gt; and the table &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;Grades&lt;/span&gt;. To find all Students that have not been graded yet you can use the difference operation. Or in terms of set theory and using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;\&lt;/span&gt; as the notation of difference:&lt;br /&gt;&lt;br /&gt;&lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;{1,2,3}&amp;nbsp;âˆ–&amp;nbsp;{2,3,4} = {1}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;Some RDBMS have the difference operation built-in using the &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;EXCEPT&lt;/span&gt; keyword. So the query in this case would be something like:&lt;br /&gt;&lt;script src=&#34;https://gist.github.com/faif/bee76fa49c0885d7b2dc.js?file=except.sql&#34;&gt;&lt;/script&gt; &lt;br /&gt;But that&#39;s not the case for MySQL. MySQL does not support &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;EXCEPT&lt;/span&gt; but we can get the same result using a &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;LEFT (OUTER) JOIN&lt;/span&gt;: &lt;/div&gt;&lt;script src=&#34;https://gist.github.com/faif/bee76fa49c0885d7b2dc.js?file=left-join.sql&#34;&gt;&lt;/script&gt;&lt;/div&gt;OK, so I used a &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;LEFT JOIN&lt;/span&gt; to find out that the query was painfully slow. One table had 700 thousand records and the other 130 thousand records. For a relational database that&#39;s not a big deal (only a few seconds, let&#39;s say maximum 3).&lt;br /&gt;&lt;br /&gt;If you search on the Web for slow &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;LEFT JOIN&lt;/span&gt; query you&#39;ll see that everyone recommends (a) adding indexes and (b) using the SQL optimizer. Well, I had already done both things without achieving my goal. I added the indexes using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;CREATE INDEX&lt;/span&gt; and then used the optimizer by adding &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;EXPLAIN&lt;/span&gt; in front of my query and made sure that the indexes were used properly.&lt;br /&gt;&lt;br /&gt;So, what&#39;s left? Actually there are two other important things to check. The first is to inspect the output of &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;SHOW PROCESSLIST&lt;/span&gt;. This will show you the list of active processes on the server. When writing queries killing the SQL client because it crashed/became unresponsive due to a bad query is not unusual. But killing the client does not necessarily mean that the query is killed. There might still be orphan queries that eat the resources of your server but you have no control of them. You can kill them using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;KILL PROCESS_ID&lt;/span&gt; (replace PROCESS_ID with the actual ID of the orphan process).&lt;br /&gt;&lt;br /&gt;The second thing that really impacts the performance of MySQL is when trying to join tables that use different collations. MySQL uses by default the legacy latin1_swedish_ci collation, so if one of the tables you are trying to join is using a different collation (for example utf8_unicode_ci, which makes much more sense as a default nowadays) the joins become terribly slow. Just make sure that all database tables use the same collation.&lt;br /&gt;&lt;br /&gt;Happy querying!&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
