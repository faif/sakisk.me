<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on Sakis Kasampalis - Personal homepage</title>
    <link>http://localhost:1313/tags/software-engineering/</link>
    <description>Recent content in Software Engineering on Sakis Kasampalis - Personal homepage</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Mar 2014 15:49:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Joy of Coding 2014 - My impressions</title>
      <link>http://localhost:1313/blog/2014-03-08-joy-of-coding-2014-my-impressions/</link>
      <pubDate>Sat, 08 Mar 2014 15:49:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2014-03-08-joy-of-coding-2014-my-impressions/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;I haven&#39;t been to a conference for years, but this year I decided to join &lt;a href=&#34;http://joyofcoding.org/&#34;&gt;Joy of Coding&lt;/a&gt;. And I don&#39;t regret it!&lt;br /&gt;&lt;br /&gt;The conference started with a keynote by Dan North: &#34;Accelerating Agile: hyper-performing       without the hype&#34;. Dan described what he learnt about Agile while working in the trading domain. The most interesting advice that I kept from his presentation is that being a good programmer is not enough: What really makes a difference is to become a domain expert. For example, if you are working as a stock market programmer, your superior programming skills don&#39;t matter if you have no clue about what the numbers mean.&lt;br /&gt;&lt;br /&gt;Next, I joined the &#34;Let Me Graph That For You: An Introduction to Neo4j&#34; workshop, by Ian Robinson. The first part of the workshop was an introduction to Graph Databases and Neo4j. At the second part we used Neo4j and its query language Cypher to create a few graphs and query them. I am impressed by how easy is to get started with Neo4j. I find its web interface very intuitive. We had a few questions for Ian (S = Sakis, I = Ian, O = Other conference participant):&lt;br /&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;S: Is there any relation between Neo4j and RDF?&lt;/li&gt;&lt;li&gt;I: Not really. In RDF you typically end up with more connections because everything is modelled as a triple. But there are libraries that can extract a Neo4j graph as RDF.&lt;/li&gt;&lt;li&gt;S: Are all the common graph algorithms (eg. SPF, BFS, Bellman-Ford, etc.) available?&lt;/li&gt;&lt;li&gt;I: Most of the well-known graph algorithms are available, and furthermore there is a Java API that is exposed and can be extended with your own algorithms.&lt;/li&gt;&lt;li&gt;S: Is Cypher case-sensitive?&lt;/li&gt;&lt;li&gt;I: Partly. The identifiers of a query are case-sensitive, but the rest parts of the query aren&#39;t.&lt;/li&gt;&lt;li&gt;O: Are there any cases where RDBMS should still be used instead of Graph Databases?&lt;/li&gt;&lt;li&gt;I: If you have tabular data and you want to focus on set theory operations (eg. union, intersection, etc.) an RDBMS is preferable.&lt;/li&gt;&lt;/ul&gt;&amp;nbsp;I&#39;ll definitely look more into Graph Databases and Neo4j.&lt;br /&gt;&lt;br /&gt;The next keynote was &#34;Contravariance is the Dual of Covariance&#34;, by Erik Meijer. I&#39;m not very familiar with Reactive Programming and Rx, thus I couldn&#39;t follow everything. But at least I enjoyed the jokes and the funny examples that Erik used. Using Scala as a reference, he explained the meanings of covariance and contra-variance, and showed how they can be used to create reusable code.&lt;br /&gt;&lt;div&gt;&lt;br /&gt;The second workshop that I joined was &#34;An Introduction to Actors and Concurrency&#34;, by Michel Rijnders and Matthijs Ooms. The first part of the workshop was basically an introduction to Erlang, thus nothing special if you are familiar with Prolog. The fun started at the second part, where we experienced how straightforward is to communicate asynchronously through the network using Erlang&#39;s actor model and message-passing primitives.&lt;br /&gt;&lt;br /&gt;Last but not least was the keynote &#34;The Tao, of the Joy, of Coding&#34;, by Dick Wall. This was by far the most inspiring keynote. Dick, using ancient Chinese philosophy as a reference, talked about many interesting topics, including programming honesty (saying &#34;I don&#39;t understand this&#34; and learning from your colleagues is a good thing), looking back as a programmer (eg. if you used your programming skills to find a cure for a disease you really changed the world), and getting a life (being proud about working until 2 AM is a very bad mentality).&lt;br /&gt;&lt;br /&gt;All in all, a great conference that I will keep in my agenda every year!&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>What we can learn from the space guys</title>
      <link>http://localhost:1313/blog/2012-07-18-what-we-can-learn-from-space-guys/</link>
      <pubDate>Wed, 18 Jul 2012 21:48:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2012-07-18-what-we-can-learn-from-space-guys/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;The &lt;a href=&#34;http://www.se-radio.net/2008/06/episode-100-software-in-space/&#34;&gt;software in space&lt;/a&gt; podcast (by se-radio) put me into thoughts about finding ways to improve code quality. First of all, I think that using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;void&lt;/span&gt; methods in languages that support exceptions is not very useful. Instead, I prefer using idioms like the &lt;a href=&#34;http://pragprog.com/magazines/2012-04/the-pragmatic-defense&#34;&gt;boolean return value and single exit point&lt;/a&gt;. Together with design by contract and sufficient testing coverage, mistakes like the Ariane 5 crash can be discovered and eliminated at an early phase -- before it&#39;s too late...&lt;br /&gt;&lt;br /&gt;The fact that there are usually two discrete programming teams developing the same space software part using different programming languages (and members with different mindsets) is extremely important. It focuses on the importance of the human factor and emphasizes on using different tools to solve the same problem as a way of writing &#34;better&#34; (for example faster, with less bugs, cleaner, more fault tolerant, etc.) code.&lt;br /&gt;&lt;br /&gt;This is aligned with one of my basic principles: Programming languages are just tools, and the right tool should be used for the right job. Dogmatic decisions increase the potential of failure.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Do you evaluate your potential employers?</title>
      <link>http://localhost:1313/blog/2012-06-03-are-you-evaluating-your-potential/</link>
      <pubDate>Sun, 03 Jun 2012 17:29:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2012-06-03-are-you-evaluating-your-potential/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;The prolonged financial crisis that we are living has caused an enormous growth in unemployment rates all over the world. Software Engineers and Programmers are by no means an exception to that rule, especially fresh graduates with no or little professional experience. But to find a job (or search for a better one) we need to (1) sit for (usually many) interviews, (2) find if there&#39;s a match between what we are looking and what the employer can provide us.&lt;br /&gt;&lt;br /&gt;Being interviewed is unfortunately no fun in most cases. The employers are looking for the perfect candidate, thus they are trying to push us as much as possible: They check our programming and software engineering skills, our communication and social skills, our logic and problem-solving skills, our future plans, etc. (the list can go forever).&lt;br /&gt;&lt;br /&gt;But what do the employers provide in exchange? A good salary? That&#39;s obviously important, but I don&#39;t think it&#39;s enough. If I have to devote at least 8 hours of my life everyday on working for someone, a good salary is not sufficient. Most employers might use some buzzwords (agile, scrum, TDD, etc.)&amp;nbsp; during an interview for convincing us to work for them. Unfortunately reality can be different, and we only find out when it&#39;s too late...&lt;br /&gt;&lt;br /&gt;So what can we do to avoid that situation? It&#39;s simple: We can also ask questions. The next time that your potential employer is going to ask you if you have any questions, surprise her by asking interesting questions similar (but not necessarily the same) to the questions of &lt;a href=&#34;http://www.joelonsoftware.com/articles/fog0000000043.html&#34;&gt;The Joel Test&lt;/a&gt;:&lt;br /&gt;&lt;ol&gt;&lt;li&gt;Do you use a distributed version control system?&lt;/li&gt;&lt;li&gt;Do you have a bug database?&amp;nbsp; &lt;/li&gt;&lt;li&gt;Can I make a build in one step using your build system?  &lt;/li&gt;&lt;li&gt;Can I suggest new programming languages/practices? &lt;/li&gt;&lt;li&gt;Do you use an agile methodology?&lt;/li&gt;&lt;li&gt;Do programmers have quiet working conditions?  &lt;/li&gt;&lt;li&gt;Do you have testers?&amp;nbsp;&lt;/li&gt;&lt;/ol&gt;In contrast to Joel&#39;s Test, simple yes/no answers should not be acceptable since the employer might not be 100% honest...&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
