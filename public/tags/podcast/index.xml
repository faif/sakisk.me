<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Podcast on Sakis Kasampalis - Personal homepage</title>
    <link>https://sakisk.me/tags/podcast/</link>
    <description>Recent content in Podcast on Sakis Kasampalis - Personal homepage</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Jul 2012 21:48:00 +0000</lastBuildDate>
    <atom:link href="https://sakisk.me/tags/podcast/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What we can learn from the space guys</title>
      <link>https://sakisk.me/blog/2012-07-18-what-we-can-learn-from-space-guys/</link>
      <pubDate>Wed, 18 Jul 2012 21:48:00 +0000</pubDate>
      <guid>https://sakisk.me/blog/2012-07-18-what-we-can-learn-from-space-guys/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;The &lt;a href=&#34;http://www.se-radio.net/2008/06/episode-100-software-in-space/&#34;&gt;software in space&lt;/a&gt; podcast (by se-radio) put me into thoughts about finding ways to improve code quality. First of all, I think that using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;void&lt;/span&gt; methods in languages that support exceptions is not very useful. Instead, I prefer using idioms like the &lt;a href=&#34;http://pragprog.com/magazines/2012-04/the-pragmatic-defense&#34;&gt;boolean return value and single exit point&lt;/a&gt;. Together with design by contract and sufficient testing coverage, mistakes like the Ariane 5 crash can be discovered and eliminated at an early phase -- before it&#39;s too late...&lt;br /&gt;&lt;br /&gt;The fact that there are usually two discrete programming teams developing the same space software part using different programming languages (and members with different mindsets) is extremely important. It focuses on the importance of the human factor and emphasizes on using different tools to solve the same problem as a way of writing &#34;better&#34; (for example faster, with less bugs, cleaner, more fault tolerant, etc.) code.&lt;br /&gt;&lt;br /&gt;This is aligned with one of my basic principles: Programming languages are just tools, and the right tool should be used for the right job. Dogmatic decisions increase the potential of failure.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>On building a platform</title>
      <link>https://sakisk.me/blog/2012-07-12-on-building-platform/</link>
      <pubDate>Thu, 12 Jul 2012 20:29:00 +0000</pubDate>
      <guid>https://sakisk.me/blog/2012-07-12-on-building-platform/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;The se-radio podcast about &lt;a href=&#34;http://www.se-radio.net/2008/10/episode-113-building-platforms-with-jeff-mcaffer/&#34;&gt;building a platform&lt;/a&gt; contains many useful tips, but the most important IMHO are (1) the importance of the API, (2) &#34;eating your own dog food&#34;.&lt;br /&gt;&lt;br /&gt;The API should be easy to use. This means that it should be intuitive for the users, which in this case are programmers. Note that the developers of the API should not decide about its flexibility and easiness. That should be decided only by the users, so the design of an API is guided by the programmers who use it. Good code documentation is also important, and in this case tools like doxygen are invaluable. Finally, backward compatibility is crucial.&lt;br /&gt;&lt;br /&gt;&#34;Eating your own dog food&#34; in this case means using your own platform, either to extend it or to develop customer products (or by being just the end customer). I find this extremely important, because when programmers develop products that they never use or don&#39;t find useful for themselves, the quality of the product is low. This is related with the &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Cathedral_and_the_Bazaar#Guidelines_for_creating_good_open_source_software&#34;&gt;&#34;Scratching an itch&#34;&lt;/a&gt; topic (see guidelines 1 and 18). Examples: Eclipse developers use Eclipse to develop it further, Apple developers use the stuff that they developed in their daily life, etc.&lt;/div&gt;</description>
    </item>
    <item>
      <title>Why Erlang matters</title>
      <link>https://sakisk.me/blog/2012-07-05-why-erlang-matters/</link>
      <pubDate>Thu, 05 Jul 2012 21:38:00 +0000</pubDate>
      <guid>https://sakisk.me/blog/2012-07-05-why-erlang-matters/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;I usually go at work by bicycle and to spend my cycling time efficiently I listen to the podcasts of&amp;nbsp; &lt;a href=&#34;http://www.se-radio.net/&#34;&gt;se-radio&lt;/a&gt;. I have this idea of sharing my thoughts about the things being said in the podcasts but I&#39;m not sure if it is going to work well. But anyway...&lt;br /&gt;&lt;br /&gt;Today&#39;s podcast was about &lt;a href=&#34;http://www.se-radio.net/2008/03/episode-89-joe-armstrong-on-erlang/&#34;&gt;Erlang&lt;/a&gt;. Erlang is a functional language which started as a Prolog derivative focusing on solving fault tolerance problems in telecommunications systems. Compared to its initial version, Erlang has evolved a lot. The performance is much better, it uses a dedicated virtual machine, and offers a framework (OTP) for developing real-time fault tolerant systems.&lt;br /&gt;&lt;br /&gt;Erlang focuses on fault tolerance using lightweight processes that communicate with each other using message passing primitives. Each process is independent from the rest, like processes in operating systems. There is no shared memory or threads, so&amp;nbsp; no need for deadlock detection/avoidance techniques, mutexes, conditional variables, and the like.&lt;br /&gt;&lt;br /&gt;Another notable feature is the &#34;let it crash&#34; philosophy. Since processes are independent, when a process crashes the rest remain unaffected. This gives the option of using special processes for monitoring the faulty processes. It&#39;s even possible to debug and replace faults in runtime.&lt;br /&gt;&lt;br /&gt;Now that single processors have reached their limits, Erlang is a great option for making efficient use of multi-core CPUs without messing with threads and hard to debug deadlocks.&lt;br /&gt;&lt;br /&gt;Obviously the Prolog-like syntax of Erlang is keeping some programmers away, but that&#39;s not a serious reason for not giving it a try.&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
