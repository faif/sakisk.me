<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Book on Sakis Kasampalis - Personal homepage</title>
    <link>http://localhost:1313/tags/book/</link>
    <description>Recent content in Book on Sakis Kasampalis - Personal homepage</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Jul 2016 22:30:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/book/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Book review: Pragmatic Guide to Git</title>
      <link>http://localhost:1313/blog/2016-07-23-book-review-pragmatic-git/</link>
      <pubDate>Sat, 23 Jul 2016 22:30:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2016-07-23-book-review-pragmatic-git/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://d.gr-assets.com/books/1348576641l/9586547.jpg&#34; alt=&#34;book cover&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;The title of this book describes it correctly. It is a compact guide&#xA;covering the basic (and a few more advanced) use cases of Git. If you&#xA;have already used Git you most likely know everything (or almost&#xA;everything) explained in this book. That was my case, but I&amp;rsquo;ve also&#xA;learnt a few new commands and concepts (like why it&amp;rsquo;s useful to use&#xA;&lt;code&gt;--&lt;/code&gt; before providing any file/path names to avoid clashing).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Book review: Seven Databases in Seven Weeks</title>
      <link>http://localhost:1313/blog/2015-11-24-book-review-seven-databases-in-seven/</link>
      <pubDate>Tue, 24 Nov 2015 15:48:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2015-11-24-book-review-seven-databases-in-seven/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;div class=&#34;description markdown collapsible&#34; style=&#34;display: block;&#34;&gt;                &lt;br /&gt;&lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://3.bp.blogspot.com/-2EpVD--5rCA/VlR2jm1W2II/AAAAAAAAAKY/L8DEgKZl4Dk/s1600/rwdata_xlargecover.jpg&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;200&#34; src=&#34;http://3.bp.blogspot.com/-2EpVD--5rCA/VlR2jm1W2II/AAAAAAAAAKY/L8DEgKZl4Dk/s200/rwdata_xlargecover.jpg&#34; width=&#34;166&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;That&#39;s a really nice book. From the seven databases  that are covered I was familiar with PostgreSQL and only briefly with  Neo4j. So the book gave me the chance to explore some more databases and  find out about their strengths and weaknesses. In the following  paragraphs I&#39;ll explain what I found nice and what not so nice about  each of them. Before I start: if you are planning to buy this book, I  want to warn you that some features are deprecated or even removed,  because some of the database systems have evolved since the time the  book was written (2012). For example the largest part of the Neo4j  chapter is useless, because it doesn&#39;t use the Cypher language.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;PostgreSQL rocks&lt;/em&gt;. It&#39;s a very powerful RDBMS and I  acknowledge that since I have used it professionally. Postgres is  mature, fast, and rock-solid. For those reasons I would choose it for  all problems that play nicely with relational DBs. And yes, an RDBMS is  not the answer to all problems. For example distributed computations do  not fit well into this model. Scaling is limited to making your single  DB server/cluster more powerful by upgrading/extending its hardware. And  not all problems require full ACID compliance and strict schema  enforcement.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;Riak&lt;/em&gt; is flexible. Being able to interact with a DB using a REST interface and a tool like &lt;code&gt;curl&lt;/code&gt; should not be underestimated. What I like about Riak is that you can  store whatever resource (be it a document, an image, etc.) you like on  the fly and map it to your URL of preference. It just works! I see Riak  as a Web filesystem that supports distributed computations through  mapreduce. But Riak also supports connecting resources and traversing  between those connections (link walking). On the down side configuring,  and understanding some Riak concepts (for example conflict resolution  and adding indexes) is currently a pain. And you can only find prebuilt  binaries for your operating system (Windows is not supported at all) on basho.com.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;HBase&lt;/em&gt; is unusual. It takes some time to understand the way a  column-oriented DB works. What I found great is that versioning is  builtin. If you care about data history that&#39;s a big deal. Another plus:  compression and fast lookups using bloom filters are also builtin.  Great features, that can save a lot of time of development. The  negatives: no REST interface, complex configuration, and no prebuilt  binaries -- you need to compile HBase on your own, so forget Windows  unless you like pain.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;MongoDB&lt;/em&gt; is all about JavaScript. Having the full  support of a powerful language like Javascript while using a DB is very  valuable. Being able to save JSON documents adds a lot of flexibility  since they can nest arbitrary. But this flexibility comes with a cost:  updating a document means replacing it without a warning, deleting  specific elements of a document is not supported and debugging  JavaScript code is a pain. On the contrary: the mapreduce support of  Mongo is nice, and it also supports indexing documents. Configuring  replicas and sharding is also quite easy. And operating system support  is very good.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;CouchDB&lt;/em&gt; is cute. The Futon Web interface makes CouchDB very user-friendly. Its REST interface and the ability to use &lt;code&gt;curl&lt;/code&gt; makes it developer-friendly. Moreover, CouchDB has an interesting  approach regarding replication, since all servers are treated equally  (no master-slave model). The same is true for conflict resolution: one  of the conflicting updates is automatically considered the winner, and  this is consistent through all nodes. But that&#39;s not necessarily the  &#34;correct&#34; update... One last thing: CouchDB is easy to install on all  popular platforms.&lt;br /&gt;&lt;br /&gt; &lt;em&gt;Neo4j&lt;/em&gt; is &lt;strong&gt;the&lt;/strong&gt; graph database. There are  simply no competitors when it comes to modelling relationships (think of  social networks, movies, food, drinks) using graphs. Neo4j has its own  query language (Cypher) and a very nice browser that makes experimenting  easy. The documentation is also extensive and interactive. Building a  cluster is easy. The negatives: learning curve (new concepts and new  language), the enterprise edition is not free (gratis).&lt;br /&gt;&lt;br /&gt; &lt;em&gt;Redis&lt;/em&gt; is generic. It&#39;s not a DB as such, but more an  in-memory data structure storage toolkit. Redis is simple to use, fast,  and supports transactions. Its commands have strange names though,  probably the result of an effort to avoid verbosity. Because it is very  generic, Redis can be used as a fast in-memory cache for applications  that require high performance.&lt;br /&gt;&lt;br /&gt; Final comments: Some people have proposed a better definition of the  name NoSQL: Not only SQL. I like this definition. Similar to programming  paradigms and languages, different database systems have both strengths  and weaknesses. Why not use more than one to achieve our goals? That&#39;s  the main idea behind the polyglot persistence concept, as suggested by  the authors. Polyglot persistence means using more than one databases to  target different application layers. For example Redis for caching,  Neo4j for modelling relationships, and PostgreSQL for persistence.&lt;br /&gt;              &lt;/div&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Book review: Pragmatic Guide to JavaScript</title>
      <link>http://localhost:1313/blog/2015-11-09-book-review-pragmatic-guide-to/</link>
      <pubDate>Mon, 09 Nov 2015 12:23:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2015-11-09-book-review-pragmatic-guide-to/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;div class=&#34;description markdown collapsible&#34;&gt;                &lt;div class=&#34;separator&#34; style=&#34;clear: both; text-align: center;&#34;&gt;&lt;a href=&#34;http://2.bp.blogspot.com/-c6J5_vJHboc/VkB_haMGIvI/AAAAAAAAAKA/2Q5WiYw-ljk/s1600/41D%252BipxJ7tL._SX331_BO1%252C204%252C203%252C200_.jpg&#34; imageanchor=&#34;1&#34; style=&#34;margin-left: 1em; margin-right: 1em;&#34;&gt;&lt;img border=&#34;0&#34; height=&#34;320&#34; src=&#34;http://2.bp.blogspot.com/-c6J5_vJHboc/VkB_haMGIvI/AAAAAAAAAKA/2Q5WiYw-ljk/s320/41D%252BipxJ7tL._SX331_BO1%252C204%252C203%252C200_.jpg&#34; width=&#34;213&#34; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;br /&gt;This was my first JavaScript book and I consider it a  good overview covering the pros and cons of the language. The author  gives good advice regarding which features of pure JavaScript are fine  to use and for which features a framework should be preferred to avoid  browser incompatibilities.&lt;br /&gt;&lt;br /&gt; Many popular applications are demonstrated (custom tooltips, infinite  scrolling, form validation, autocompletion, lightbox, 3rd party APIs)  and concepts such as client vs server programming are clearly explained.  Christophe&#39;s &lt;a href=&#34;http://www.amazon.com/Pragmatic-Guide-JavaScript-Programmers/product-reviews/1934356670/ref=cm_cr_dp_see_all_summary?ie=UTF8&amp;amp;showViewpoints=1&amp;amp;sortBy=byRankDescending&#34;&gt;focus on Prototype&lt;/a&gt; is not a problem for me. It&#39;s his  favorite framework and the one that he knows well, so it make sense that  he&#39;s using it for the demos.&lt;br /&gt;&lt;br /&gt;One practical problem: this book is not maintained any more, and as a consequence a few examples are broken, due to a domain that has expired and changes to the Twitter API. I contacted the author on &lt;a href=&#34;https://github.com/tdd/pragmatic-javascript/issues/2&#34;&gt;GitHub &lt;/a&gt;and he confirmed it. But still, for a book that was published five years ago it&#39;s a nice compact guide to people who are familiar with programming and want to focus on the specifics of JavaScript.&lt;br /&gt;              &lt;/div&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>On writing a book</title>
      <link>http://localhost:1313/blog/2015-02-02-on-writing-book/</link>
      <pubDate>Mon, 02 Feb 2015 20:08:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2015-02-02-on-writing-book/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;After &lt;a href=&#34;http://sakiskasampalis.blogspot.nl/2013/11/my-first-book-review.html&#34;&gt;reviewing&lt;/a&gt; &lt;a href=&#34;http://sakiskasampalis.blogspot.nl/2014/05/being-technical-reviewer-again.html&#34;&gt;two&lt;/a&gt; books about Python, people from Packt asked me if I was willing to write a Python book. I&#39;m glad to see that my first book, &lt;a href=&#34;https://www.packtpub.com/application-development/mastering-python-design-patterns&#34;&gt;Mastering Python Design Patterns&lt;/a&gt; is published!&lt;br /&gt;&lt;br /&gt;As I expected, writing a book is much tougher than reviewing one. Especially if you have a full-time job, like in my case. I had to deliver a chapter about every week. This is very challenging, since it means that I had to spend many evenings and weekends focusing on delivering a chapter on time.&lt;br /&gt;&lt;br /&gt;I hope that my book will be appreciated by the Python (3.x) community. I tried to focus on doing things the Python way instead of reproducing Java-ish or C++-style solutions. To be honest I preferred a different title: I recommended the title &#34;Idiomatic Python Design Patterns&#34; but my proposal was rejected, mainly for marketing reasons.&lt;br /&gt;&lt;br /&gt;If you are also considering writing a book, I think that it is a very good idea, but take into account the following:&lt;br /&gt;&lt;br /&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;Do you have the time to do it? Unless your book is self-published, you&#39;ll need to sign a contract with a publisher and that means that there will be deadlines. Make sure that you discuss it first with your partner/family, since it is a demanding task.&lt;/li&gt;&lt;li&gt;Does it fill a missing gap? I don&#39;t recommend you to write a book just for the money (yes, you are paid for writing the book and depending on the contract you can also get a share from the sales). I have seen many examples of poorly-written books that were created only because the author wanted to make some money. Don&#39;t do it. It might be good for you pocket, but it can harm your reputation, your career, and your psychology (think of bad reviews).&lt;/li&gt;&lt;/ul&gt;&lt;div&gt;To expand a little bit more on point two: I feel that my book is indeed filling a gap. Although there are other books about Design Patterns in Python, none of them focuses on Python 3. In fact, I reviewed one of them, and apart from targeting only Python 2.x, IMHO it is not using idiomatic Python solutions in many cases.&lt;/div&gt;&lt;div&gt;&lt;br /&gt;&lt;/div&gt;&lt;div&gt;My book is not perfect in any way. The lack of time meant that some examples had to be smaller and more trivial than expected. But this is part of the game. If you are working full-time and you are writing a book, time is your enemy! Be prepared to make compromises...&lt;/div&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Course review: SQL Performance</title>
      <link>http://localhost:1313/blog/2015-01-14-course-review-sql-performance/</link>
      <pubDate>Wed, 14 Jan 2015 21:30:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2015-01-14-course-review-sql-performance/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;&lt;b&gt;Update:&lt;/b&gt; Markus was kind enough to comment on my review. Regarding the &#34;minimise the number of tables to limit joins&#34; he said:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;it is often the best approach to store some attribute redundant (e.g.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica;&#34;&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;normalised&amp;nbsp;as before plus wherever needed). Maintenance of this&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;redundancy should be delegated to the database whenever possible (e.g.&amp;nbsp;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica;&#34;&gt;&lt;span style=&#34;font-size: 12px;&#34;&gt;using triggers or&amp;nbsp;materialised&amp;nbsp;view). You should not do that before&amp;nbsp;having those performance problems (avoid &#34;premature&amp;nbsp;optimisation&#34;).&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;Reducing the number of joins is a good way to get performance. But only once you are in that situation. And of course, there are other, simpler ways to improve performance that should be leveraged first (e.g, good-old indexing).&lt;/span&gt;&lt;/blockquote&gt;So I&#39;m glad that we agree that normalisation is a good thing and that we should only try to find alternative solutions if nothing else (e.g. proper indexing) works.&lt;br /&gt;&lt;br /&gt;Markus also made an important comment about the column order in the WHERE clause that is not clarified in my original post:&lt;br /&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;The column order in indexes matters a lot&lt;/span&gt;&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;blockquote class=&#34;tr_bq&#34;&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;&lt;span style=&#34;font-family: Helvetica; font-size: 12px;&#34;&gt;The column order in the WHERE clause doesn&#39;t matter (rare exceptions exist, but generally, it doesn&#39;t!).&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;br /&gt;&lt;br /&gt;The original post starts here...&lt;br /&gt;&lt;br /&gt;Last &lt;strike&gt;October&lt;/strike&gt;&amp;nbsp;November I followed a course related to the performance of SQL. The course was given by &lt;a href=&#34;http://use-the-index-luke.com/&#34;&gt;Markus Winand&lt;/a&gt;. Although we don&#39;t agree on everything (for example I don&#39;t like the &#34;create as few tables as possible to minimise joins and achieve better performance&#34; principle because it is against normalisation) Markus has a great knowledge of general and RDBMS-specific performance related issues.&lt;br /&gt;&lt;br /&gt;I&#39;m glad that I followed this course. Markus gave us a copy of &lt;a href=&#34;http://sql-performance-explained.com/?utm_source=UTIL&amp;amp;utm_medium=main&amp;amp;utm_campaign=second&#34;&gt;his book&lt;/a&gt; which is very compact and to the point. This is an example of a book that I would never consider reading but it turns out to be a hidden gem. I recommend it to everyone working with relational databases.&lt;br /&gt;&lt;br /&gt;It took me some time to write this post because I wanted to read the book first. In this book you will find things that you don&#39;t know for sure. For example, did you know that:&lt;br /&gt;&lt;ul style=&#34;text-align: left;&#34;&gt;&lt;li&gt;When building indexes on more than one columns (concatenated indexes), the order of the columns matters a lot?&lt;/li&gt;&lt;li&gt;The order of the statements in the &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;WHERE&lt;/span&gt; part of a query affects whether a concatenated index is used or not?&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;LIKE&lt;/span&gt; expressions with leading wildcards (eg. &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;&#39;%SQL&#39;&lt;/span&gt;) cannot make use of an index?&lt;/li&gt;&lt;li&gt;ORMs can cause big performance problems because of the bad queries that they generate?&lt;/li&gt;&lt;li&gt;Selecting only the necessary columns (avoid &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;SELECT *&lt;/span&gt;) can improve the performance of joins?&lt;/li&gt;&lt;li&gt;An index that covers all the columns of an SQL query (including the columns of the &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;SELECT&lt;/span&gt; part) does not need to access any other data structures except the index and improves the performance of a query enormously?&lt;/li&gt;&lt;li&gt;&lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;ORDER BY&lt;/span&gt; and &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;GROUP BY&lt;/span&gt; can also be indexed?&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;The main message of the book is that indexes should be built by us, the developers, not by DBAs or anyone else. That&#39;s because only we know how the data are queried, and therefore only we can build the proper indexes.&lt;br /&gt;&lt;br /&gt;Personally, I&#39;m very sad to see how many features that are supported by other RDBMS are not supported by MySQL. To mention a few: indexing functions and expressions, partial indexes, indexing using &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;ASC&lt;/span&gt; and &lt;span style=&#34;font-family: &amp;quot;Courier New&amp;quot;,Courier,monospace;&#34;&gt;DESC&lt;/span&gt;, window functions. Fortunately, MariaDB is getting there and I hope that we&#39;ll switch to it (at work) at some point.&lt;/div&gt;</description>
    </item>
    <item>
      <title>Being a technical reviewer (again)</title>
      <link>http://localhost:1313/blog/2014-05-04-being-technical-reviewer-again/</link>
      <pubDate>Sun, 04 May 2014 12:53:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2014-05-04-being-technical-reviewer-again/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;A few months ago I experienced (for the first time) how it feels to be part of a technical reviewing team. I reviewed a packt introductory &lt;a href=&#34;http://sakiskasampalis.blogspot.nl/2013/11/my-first-book-review.html&#34;&gt;book&lt;/a&gt; about Design Patterns.&lt;br /&gt;&lt;br /&gt;Today I&#39;m glad to see that another packt book, of which I was for once again one of the technical reviewers, has been published. The book is called &lt;a href=&#34;http://www.packtpub.com/mastering-object-oriented-python/book&#34;&gt;Mastering Object-oriented Python&lt;/a&gt;. It&#39;s a book that focuses on writing OOP code in Python 3.&lt;br /&gt;&lt;br /&gt;I would recommend this book to all Python programmers, both beginners and advanced. It covers all aspects of the language (to mention a few: special methods, unit testing, decorators, serialization, etc.) and shows different possible designs, explaining the pros and cons of each design. What I really like is that the code in the book is written in a Pythonic style, and the author makes a good job at explaining how Python differs from Java/C++.&lt;br /&gt;&lt;br /&gt;A few warnings: This is a big book (~ 600 pages). You can read the whole thing, but I believe that it will be much more useful as a handbook. Also note that the book assumes familiarity with Python 3 and Design Patterns.&lt;br /&gt;&lt;br /&gt;You might wonder why I accepted to do again a technical review. Some people find technical reviewing a waste of time. But I disagree. To become a good programmer, you need to read a lot of code instead of just writing. In fact, programmers tend to read much more existing code than write new code. If reading code is important, reading good code is much more important. And I believe that the code in this book is well written.&lt;/div&gt;</description>
    </item>
    <item>
      <title>My first book review</title>
      <link>http://localhost:1313/blog/2013-11-28-my-first-book-review/</link>
      <pubDate>Thu, 28 Nov 2013 21:52:00 +0000</pubDate>
      <guid>http://localhost:1313/blog/2013-11-28-my-first-book-review/</guid>
      <description>&lt;div dir=&#34;ltr&#34; style=&#34;text-align: left;&#34; trbidi=&#34;on&#34;&gt;During the last month(s) I participated in the review process of a book about Design Patterns in Python. I am happy to see that the book has been released. The title of it is &lt;a href=&#34;http://www.packtpub.com/learning-python-design-patterns/book&#34;&gt;Learning Python Design Patterns&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;Reviewing a book is definitely not harder than writing one, but that doesn&#39;t mean that it&#39;s not challenging. The comments must be clear in context, useful, and not offensive. The process requires a considerable amount of time since all comments/remarks/notes must be backed by research and reliable references.&lt;br /&gt;&lt;br /&gt;Nevertheless, I enjoyed the whole procedure which thanks to the people of packt publishing (packtpub) was flexible and clear. Plus, I&#39;ll receive a free hard-copy of the book that I reviewed and a copy of my favourite packtpub ebook. Not bad!&lt;br /&gt;&lt;br /&gt;In the future I hope that I&#39;ll have the chance (and the time) to write my own book about a topic that I like.&lt;/div&gt;</description>
    </item>
  </channel>
</rss>
